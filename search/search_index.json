{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#usage","title":"Usage","text":""},{"location":"#classes-decorators","title":"Classes &amp; decorators","text":"<p>In Tawazi, there 3 Classes that will be manipulated by the user:</p> <ol> <li> <p><code>ExecNode</code>: a wrapper around a function. <code>ExecNode</code> can be executed inside a <code>DAG</code>.  <code>ExecNode</code> can take arguments and return values to be used as arguments in another object of type <code>ExecNode</code>.</p> </li> <li> <p><code>DAG</code> / <code>AsyncDAG</code>: a wrapper around a function that defines a dag dependency. This function should only contain calls to objects of type <code>ExecNode</code> or <code>DAG</code>.<p></p> Hint: Calling normal Python functions inside a <code>DAG</code> is not supported.</p> </li> <li> <p><code>DAGExecution</code> / <code>AsyncDAGExecution</code>: an instance related to <code>DAG</code> for advanced usage. It can execute a <code>DAG</code> and keeps information about the last execution. It allows checking all <code>ExecNode</code>s results, running subgraphs, caching <code>DAG</code> executions and more (c.f. section below for usage documentation).</p> </li> </ol> <p>Decorators are provided to create the previous classes:</p> <ol> <li><code>@xn</code>: creates <code>ExecNode</code> from a function.</li> <li><code>@dag</code>: creates <code>DAG</code> from a function.</li> </ol>"},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>from tawazi import xn, dag\n@xn\ndef incr(x):\nreturn x + 1\n# incr is no longer a function\n# incr became a `LazyExecNode` which is a subclass of `ExecNode`.\nprint(type(incr))\n## &lt;class 'tawazi.node.node.LazyExecNode'&gt;\n@xn\ndef decr(x):\nreturn x - 1\n@xn\ndef display(x):\nprint(x)\n@dag\ndef pipeline(x):\nx_lo = decr(x)\nx_hi = incr(x)\ndisplay(x_hi)\ndisplay(x_lo)\n# pipeline is no longer a function\n# pipeline became a `DAG`\nprint(type(pipeline))\n## &lt;class 'tawazi._dag.dag.DAG'&gt;\n# `DAG` can be executed, they behave the same as the original function without decorators.\npipeline(0)\n</code></pre>"},{"location":"#execnode-call","title":"ExecNode call","text":"<p>By default, calling <code>ExecNode</code> outside of a <code>DAG</code> describing function will raise an error. </p> <p>However, the user can control this behavior by setting the environment variable <code>TAWAZI_EXECNODE_OUTSIDE_DAG_BEHAVIOR</code> to:</p> <ol> <li><code>\"error\"</code>: raise an error if an <code>ExecNode</code> is called outside of <code>DAG</code> description (default)</li> <li><code>\"warning\"</code>: raise a warning if an <code>ExecNode</code> is called outside of <code>DAG</code> description, but execute the wrapped function anyway</li> <li><code>\"ignore\"</code>: execute the wrapped function anyway.</li> </ol> <p>This way, <code>ExecNode</code> can still be called outside a <code>DAG</code>. It will raise a warning.</p> <pre><code># set environment variable to warning\nfrom tawazi import cfg\ncfg.TAWAZI_EXECNODE_OUTSIDE_DAG_BEHAVIOR = \"warning\"\ndisplay('Hello World!')\n# &lt;stdin&gt;:1: UserWarning: Invoking LazyExecNode display ~ | &lt;0x7fdc03d4ebb0&gt; outside of a `DAG`. Executing wrapped function instead of describing dependency.\n# prints Hello World!\n</code></pre> <p>This makes it possible - in some cases - to debug your code outside Tawazi's scheduler and inspect data content between different <code>ExecNode</code>s. Simply remove <code>@dag</code> from the <code>pipeline</code> function and run it again.</p> <pre><code>@dag\ndef pipeline(x):\nx_lo = decr(x)\nx_hi = incr(x)\ndisplay(x_hi)\ndisplay(x_lo)\nreturn x\nassert pipeline(10) == 10\n#@dag  # comment out the decorator\ndef pipeline(x):\nx_lo = decr(x)\nx_hi = incr(x)  # put breakpoint here and debug!\ndisplay(x_hi)\ndisplay(x_lo)\nreturn x\nassert pipeline(10) == 10\n</code></pre>"},{"location":"#dag-components-parallelism","title":"DAG component's Parallelism","text":"<p>You can use Tawazi to make your non CPU-Bound code run in parallel.</p> <p><pre><code>from time import sleep, time\n@xn\ndef a():\nprint(\"Function 'a' is running\", flush=True)\nsleep(1)\nreturn \"A\"\n@xn\ndef b():\nprint(\"Function 'b' is running\", flush=True)\nsleep(1)\nreturn \"B\"\n@xn\ndef c(a, b):\nprint(\"Function 'c' is running\", flush=True)\nprint(f\"Function 'c' received {a} from 'a' &amp; {b} from 'b'\", flush=True)\nreturn f\"{a} + {b} = C\"\n@dag(max_concurrency=2)\ndef pipeline():\nres_a = a()\nres_b = b()\nres_c = c(res_a, res_b)\nreturn res_c\nt0 = time()\n# executing the dag takes a single line of code\nres = pipeline()\nexecution_time = time() - t0\nassert execution_time &lt; 1.5  # a() and b() are executed in parallel\nprint(f\"Graph execution took {execution_time:.2f} seconds\")\nprint(f\"res = {res}\")\n## Graph execution took 1.00 seconds\n## 'A + B = C'\n</code></pre> As you can see, the execution time of pipeline takes less than 2 seconds, which means that the code ran in parallel.</p>"},{"location":"#passing-arguments-into-a-dag","title":"Passing arguments into a <code>DAG</code>","text":"<p>A <code>DAG</code> object is callable, hence it is similar to a normal function. You can pass in arguments to the pipeline and get returned results back:</p> <p><pre><code>from tawazi import xn, dag\n@xn\ndef xn1(i):\nreturn i+1\n@xn\ndef xn2(i, j=1):\nreturn i + j + 1\n@dag\ndef pipeline(i=0):\nres1 = xn1(i)\nres2 = xn2(res1)\nreturn res2\n# run pipeline with default parameters\nassert pipeline() == 3\n# run pipeline with passed parameters\nassert pipeline(1) == 4\n</code></pre> Currently, you cannot pass in keyword arguments to the <code>DAG</code> (will be supported in future releases).</p> <p>Hint: This should not be confused with passing keyworded arguments to <code>ExecNode</code>s which is possible.</p> <p>A <code>DAG</code>-decorated function can support returning multiple values from a pipeline via tuples, lists or dicts (depth of 1 only).</p> <pre><code>@dag\ndef pipeline_tuple():\nreturn xn1(1), xn2(1)\nassert pipeline_tuple() == (2, 3)\n@dag\ndef pipeline_list():\nreturn [xn1(1), xn2(2)]\nassert pipeline_list() == [2, 4]\n@dag\ndef pipeline_dict():\nreturn {\"foo\": xn1(1), \"bar\": xn2(3)}\nassert pipeline_dict() == {\"foo\": 2, \"bar\": 5}\n</code></pre>"},{"location":"#return-types-for-an-execnode","title":"Return types for an <code>ExecNode</code>","text":"<p><code>ExecNode</code> supports returning multiple values: </p> <ol> <li>For objects of type <code>Tuple</code> and <code>List</code> in Python, you need to specify the unpacking number</li> </ol> <p><pre><code>@xn(unpack_to=4)\ndef replicate_tuple(val):\nreturn (val, val + 1, val + 2, val + 3)\n@xn(unpack_to=4)\ndef replicate_list(val):\nreturn [val, val + 1, val + 2, val + 3]\n@dag\ndef pipeline():\nv1, v2, v3, v4 = replicate_tuple(1)  # notice unpacked values here\nv5, v6, v7, v8 = replicate_list(v4)  # and here\nreturn v1, v2, v3, v4, v5, v6, v7, v8\nassert pipeline() == (1, 2, 3, 4, 4, 5, 6, 7)\n</code></pre> 2. Or via indexing (<code>Dict</code> or <code>List</code> etc.):</p> <p><pre><code>@xn\ndef gen_dict(val):\nreturn {\"k1\": val, \"k2\": \"2\", \"nested_list\": [1 ,11, 3]}\n@xn\ndef gen_list(val):\nreturn [val, val + 1, val + 2, val + 3]\n@xn\ndef incr(val):\nreturn val + 1\n@dag\ndef pipeline(val):\nd = gen_dict(val)\nl = gen_list(d[\"k1\"])  # indexing a dict\ninc_val = incr(l[0])  # indexing a list / tuple\ninc_val_2 = incr(d[\"nested_list\"][1])  # indexing a list / tuple\nreturn d, l, inc_val, inc_val_2\nd, l, inc_val, inc_val_2 = pipeline(123)\nassert d == {\"k1\": 123, \"k2\": \"2\", \"nested_list\": [1 ,11, 3]}\nassert l == [123, 124, 125, 126]\nassert inc_val == 124\nassert inc_val_2 == 12\n</code></pre> This makes the <code>DAG</code> usage as close to using the original pipeline function as possible.</p>"},{"location":"#setup-execnode","title":"Setup ExecNode","text":"<p><code>ExecNode</code> of type SetupExecNode have their results cached in the <code>DAG</code> instance. This means that they run once per <code>DAG</code> instance. These can be used to load large constant data from Disk (Machine Learning Models, Large CSV files, initialization of a resource, prewarming etc.)</p> <p><pre><code>LARGE_DATA = \"Long algorithm to generate Constant Data\"\n@xn(setup=True)\ndef setup_node():\nglobal setup_counter\nsetup_counter += 1\nreturn LARGE_DATA\n@xn\ndef my_print(arg):\nprint(arg)\nreturn arg\n@dag\ndef pipeline():\ncst_data = setup_node()\nlarge_data = my_print(cst_data)\nreturn large_data\nsetup_counter = 0\n# create another instance because setup ExecNode result is cached inside the instance\nassert LARGE_DATA == pipeline()\nassert setup_counter == 1\nassert LARGE_DATA == pipeline()\nassert setup_counter == 1 # setop_counter is skipped the second time pipe1 is invoked\n</code></pre> if you want to re-run the setup <code>ExecNode</code>, you have to redeclare the <code>DAG</code> or deepcopy the original <code>DAG</code> instance before executing it.</p> <p><pre><code>from copy import deepcopy\n@dag\ndef pipeline():\ncst_data = setup_node()\nlarge_data = my_print(cst_data)\nreturn large_data\nsetup_counter = 0\nassert LARGE_DATA == deepcopy(pipeline)()\nassert setup_counter == 1\nassert LARGE_DATA ==  deepcopy(pipeline)()\nassert setup_counter == 2\n</code></pre> You can run the setup <code>ExecNode</code> alone:</p> <p><pre><code>@dag\ndef pipeline():\ncst_data = setup_node()\nlarge_data = my_print(cst_data)\nreturn large_data\npipeline.setup()\n</code></pre> The goal of having setup <code>ExecNode</code> is to load only the necessary resources when a subgraph is executed. Here is an example demonstrating it:</p> <pre><code>from pprint import PrettyPrinter\n@xn(setup=True)\ndef setup_node_1():\nreturn \"large data 1\"\n@xn(setup=True)\ndef setup_node_2():\nreturn \"large data 2\"\n@xn\ndef print_xn(val):\nprint(val)\n@xn\ndef pprint_xn(val):\nPrettyPrinter(indent=4).pprint(val)\n@dag\ndef pipeline():\ndata1 = setup_node_1()\ndata2 = setup_node_2()\nprint_xn(data1)\npprint_xn(data2)\nreturn data1, data2\nexec_ = pipeline.executor(target_nodes=[\"print_xn\"])\n# Notice how the execution of the subgraph doesn't run the setop1 `ExecNode`.\n# This makes development of your complex pipeline faster by loading only the necessary resources.\nassert (\"large data 1\", None) == exec_()\n</code></pre>"},{"location":"#debug-execnode","title":"Debug <code>ExecNode</code>","text":"<p>You can make Debug an <code>ExecNode</code> that will only run if <code>RUN_DEBUG_NODES</code> env variable is set. This can be visualization <code>ExecNode</code>  for example or some complicated assertions that helps you debug problems when needed that are hostile to the production environment (they consume too much computation time):</p> <pre><code>@xn\ndef a(i):\nreturn i + 1\n@xn(debug=True)\ndef print_debug(i):\nglobal debug_has_run\ndebug_has_run = True\nprint(\"DEBUG: \", i)\n@dag\ndef pipe():\ni = a(0)\nprint_debug(i)\nreturn i\ndebug_has_run = False\npipe()\nassert debug_has_run == False\n## You can enable running Debug nodes \n## export RUN_DEBUG_NODES=True  # in the shell\n## debug_has_run = False\n## pipe()\n## assert debug_has_run == True\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#tag","title":"Tag","text":"<p>A tag is a user defined identifier for an <code>ExecNode</code>. Every <code>ExecNode</code> is allowed to have zero, one or multiple tags.</p> <p>You can tag an <code>ExecNode</code> with an <code>str</code>. For multiple tags simply use a tuple (<code>Tuple[str]</code>).</p> <p><pre><code>@xn(tag=(\"twinkle toes\", \"hot bird\"))\ndef a():\nprint(\"I am tough\")\n@xn(tag=(\"yummy jam\"))\ndef c():\nprint(\"I am normal\")\n@dag\ndef pipeline():\na()\nc()\npipeline()\nxn_a, = pipeline.get_nodes_by_tag(\"twinkle toes\")\nxn_b, = pipeline.get_nodes_by_tag(\"hot bird\")\nxn_c, = pipeline.get_nodes_by_tag(\"yummy jam\")\nassert xn_a == xn_b\n</code></pre> You can do whatever you want with this ExecNode:</p> <ol> <li>like looking in its arguments</li> <li>setting its priority</li> <li>changing it to become a debug <code>ExecNode</code></li> </ol> <p>WARNING: This is an advanced usage. Your methods might break more often with Tawazi releases because <code>ExecNode</code> is an internal Object. Please use with care</p> <p>You can have multiple <code>Tag</code>s for the same <code>ExecNode</code> and the same <code>Tag</code> for multiple <code>ExecNode</code>s:</p> <pre><code>@xn(tag=(\"twinkle\", \"toes\"))\ndef a():\nprint(\"I am tough\")\n@xn(tag=\"twinkle\")\ndef b():\nprint(\"I am light\")\n@dag\ndef pipeline():\na()\nb()\nxn_a, xn_b = pipeline.get_nodes_by_tag(\"twinkle\")\n</code></pre> <p>You can even tag a specific call of an ExecNode:</p> <pre><code>@xn\ndef stub_xn(i):\nreturn i\n@xn(tag=\"c_node\")\ndef print_xn(i):\nprint(i)\n@dag\ndef pipeline():\nb()\nhello = stub_xn(\"hello\")\nprint_xn(hello)\ngoodbye = stub_xn(\"goodbye\")\nprint_xn(goodbye, twz_tag=\"byebye\")\npipeline()\n# multiple nodes can have the same tag!\nxns_bye = pipeline.get_nodes_by_tag(\"byebye\")\n</code></pre> <p>This will be useful if you want to run a subgraph (cf. the next paragraph). It will also be useful if you want to access result of a specific ExecNode after an Execution</p>"},{"location":"#dagexecution","title":"<code>DAGExecution</code>","text":"<p><code>DAGExecution</code> is a class that contains a reference to the <code>DAG</code>. It is used to run a <code>DAG</code> or a subgraph of the <code>DAG</code>. After execution, the results of <code>ExecNode</code>s are stored in the <code>DAGExecution</code> instance. Hence you can access intermediate results after execution.</p> <p><pre><code>from tawazi import DAGExecution\n# construct a DAGExecution from a DAG by doing\ndx = DAGExecution(pipeline)\n# or\ndx = pipeline.executor()\n</code></pre> You can run a subgraph of your pipeline: Make a <code>DAGExecution</code> from your <code>DAG</code> and use <code>target_nodes</code> parameter to specify which <code>ExecNode</code> to run.</p> <p>The <code>DAG</code> will execute until the specified <code>ExecNode</code>s are executed and all other <code>ExecNode</code>s will be skipped.</p> <p><pre><code>pipe_exec = pipeline.executor(target_nodes=[b])\npipe_exec()\n</code></pre> In order to specify your target nodes, you can use what is called an <code>Alias</code> of the ExecNode. it can be its <code>__qualname__</code> or its <code>tag</code> or a reference to the <code>ExecNode</code> itself.</p> <p>For example using <code>__qualname__</code>:</p> <p><pre><code>pipe_exec = pipeline.executor(target_nodes=[\"b\"])\npipe_exec()\n</code></pre> Or using its <code>tag</code>:</p> <p><pre><code>pipe_exec = pipeline.executor(target_nodes=[\"c_node\"])\npipe_exec()\n</code></pre> Or using its calling tag to distinguish the 1st call of g from the 2nd call:</p> <p><pre><code>pipe_exec = pipeline.executor(target_nodes=[\"byebye\"])\npipe_exec()\n</code></pre> Or using a reference to itself. You can mix the Alias types too:</p> <pre><code>pipe_exec = pipeline.executor(target_nodes=[\"b\", xns_bye[0]])\npipe_exec()\n</code></pre> <p>Warning</p> <p>Because <code>DAGExecution</code> instances are mutable, they are not thread-safe. This is unlike <code>DAG</code> which is ThreadSafe. Create a DAGExecution per thread if you want to run the same <code>DAG</code> in parallel.</p> <p>Additionally, you can build a subgraph with the paths you want to include by declaring the root nodes where those paths begin, with the <code>root_nodes</code> argument:</p> <p><pre><code>pipe_exec = pipeline.executor(root_nodes=[\"b\"])  # will select all nodes depending on \"b\"\npipe_exec()\n</code></pre> This can of course be combined with <code>target_nodes</code>, allowing to select only specific parts of the graph.</p>"},{"location":"#basic-operations-between-nodes","title":"Basic Operations between nodes","text":"<p><code>UsageExecNode</code> implements almost all basic operations (addition, substraction, ...).</p> <p><pre><code>@xn\ndef gen_data(x):\nreturn (x + 1) ** 2\n@xn(debug=True)\ndef my_print(x):\nprint(f\"x={x}\")\n@dag\ndef pipe(x, y):\nx,y = gen_data(x), gen_data(y)\n# notice the +,-,* operations are applied directly to ExecNode's results\nreturn -x, -y, x+y, x*y\nassert pipe(1, 2) == (-4, -9, 13, 36)\n</code></pre> It's not possible to support logical operations <code>and</code>, <code>or</code> and <code>not</code> since <code>__bool__</code> should always return a <code>boolean</code>. during the dependency description phase, all <code>xn</code> decorated functions return <code>UsageExecNode</code>. However bitwise logical operators are implemented so that bitwise <code>&amp;</code> can be used inside a <code>DAG</code>.</p> <p><code>&amp;</code>, <code>|</code> vs <code>and</code>, <code>or</code></p> <p><code>&amp;</code> and <code>|</code> have different behavior than <code>and</code> and <code>or</code> in python. <code>and</code> and <code>or</code> are short-circuiting while <code>&amp;</code> and <code>|</code> are not. This is because <code>and</code> and <code>or</code> are logical operators while <code>&amp;</code> and <code>|</code> are bitwise operators.</p> <pre><code>@dag\ndef pipe(x: bool, y: bool):\nreturn x &amp; y, x | y\nassert pipe(True, False) == (False, True)\n</code></pre>"},{"location":"#conditional-execution","title":"Conditional Execution","text":"<p><code>ExecNode</code>s can be executed conditionally by passing a <code>bool</code> to the added parameter <code>twz_active</code>. This parameter can be a constant or a result of an execution of other <code>ExecNode</code> in the <code>DAG</code>. Since basic boolean operations are implemented on <code>UsageExecNode</code>s, you can use bitwise operations (<code>&amp;</code>, <code>or</code>) to simulate <code>and</code>, <code>or</code>; however this is not recommended, please use the provided <code>and_</code>, <code>or_</code> and <code>not_</code> <code>ExecNode</code>s instead.</p> <pre><code>from tawazi import and_\n@xn\ndef f1(x):\nreturn x ** 2 + 1\n@xn\ndef f2(x):\nreturn x ** 2 - 1\n@xn\ndef f3(x):\nreturn x ** 3\n@xn\ndef wrap_dict(x):\nreturn {\"value\": x}\n@dag\ndef pipe(x):\nv1 = f1(x, twz_active=x &gt; 0)  # equivalent to if x &gt; 0: v1 = f1(x)\nv2 = f2(x, twz_active=x &lt; 0)  # equivalent to if x &lt; 0: v2 = f2(x)\n# you can also write `v3 = f3(x, twz_active=(x &gt; 1) &amp; (x &gt; 0))`\nv3 = f3(x, twz_active=and_(x &gt; 1, x &gt; 0))\n# When twz_active is False, the ExecNode is not executed and returns None\nreturn v1, v2, v3\nassert pipe(-1) == (None, 0, None)\nassert pipe(2) == (5, None, 8)\nassert pipe(0) == (None, None, None)\n</code></pre>"},{"location":"#fine-control-of-parallel-execution","title":"Fine Control of Parallel Execution","text":"<ol> <li>You can control which node is preferred to run 1st when multiple <code>ExecNode</code>s are available for execution. This can be achieved through modifications of <code>priority</code> attribute of the <code>ExecNode</code>.</li> <li>You can even make an <code>ExecNode</code> run alone (i.e. without allowing other ExecNodes to execute in parallel to it). This can be helpful if you write code that is not thread-safe or use a library that is not thread-safe in a certain <code>ExecNode</code>. This is achieved by setting the <code>is_sequential</code> parameter to <code>True</code> for the <code>ExecNode</code> in question. The default value is set via the environment variable <code>TAWAZI_IS_SEQUENTIAL</code> (c.f. <code>tawazi.config</code>).</li> </ol> <pre><code>from time import sleep, time\nfrom tawazi import xn, dag\n@xn\ndef a():\nprint(\"Function 'a' is running\", flush=True)\nsleep(1)\nreturn \"A\"\n# optionally configure each ExecNode using the decorator:\n# is_sequential = True to prevent ExecNode from running in parallel with other ExecNodes\n# priority to choose the ExecNode in the next execution phase\n@xn(is_sequential=True, priority=10)\ndef b():\nprint(\"Function 'b' is running\", flush=True)\nsleep(1)\nreturn \"B\"\n@xn\ndef c(a, arg_b):\nprint(\"Function 'c' is running\", flush=True)\nprint(f\"Function 'c' received {a} from 'a' &amp; {arg_b} from 'b'\", flush=True)\nreturn f\"{a} + {arg_b} = C\"\n# optionally customize the DAG\n@dag(max_concurrency=2)\ndef deps_describer():\nres_a = a()\nres_b = b()\nres_c = c(res_a, res_b)\nreturn res_a, res_b, res_c\nt0 = time()\n# the dag instance is reusable.\n# This is recommended if you want to do the same computation multiple times\nres_a, res_b, res_c = deps_describer()\nexecution_time = time() - t0\nprint(f\"Graph execution took {execution_time:.2f} seconds\")\nassert res_a == \"A\"\nassert res_b == \"B\"\nassert res_c == \"A + B = C\"\n</code></pre>"},{"location":"#dag-composition","title":"DAG Composition","text":"<p>Experimental</p> <p>You can compose a sub-<code>DAG</code> from your original <code>DAG</code>. This is useful if you want to reuse a part of your <code>DAG</code>. Using the <code>DAG.compose</code> method, you provide the inputs and the outputs of the composed sub-<code>DAG</code>. Order is kept.</p> <p>Inputs and outputs are communicated using <code>Alias</code>: either the <code>ExecNode</code> reference or the tag/id (<code>__qualname__</code>) of the <code>ExecNode</code>. Any ambiguity will raise an <code>Error</code>.</p> <p>Warning</p> <p>All necessary inputs should be provided to produce the desired outputs. Otherwise an <code>ValueError</code> is raised.</p> <pre><code>@xn\ndef add(x, y):\nreturn x + y\n@xn\ndef mul(x, y):\nreturn x * y\n@dag\ndef pipe(x, y, z, w):\nv1 = add(1, x, twz_tag=\"add_v1\")\nv2 = add(v1, y)\nv3 = add(v2, z, twz_tag=\"add_v3\")\nv4 = mul(v3, w)\nreturn v4\nassert pipe(2,3,4,5) == 50\n# declare a sub-dag that only depends on v1, y, z and produces v3\nsub_dag = pipe.compose(qualname=\"my_composed_dag\", inputs=[\"add_v1\", \"pipe&gt;!&gt;y\", \"pipe&gt;!&gt;z\"], outputs=\"add_v3\")\nassert sub_dag(2,3,4) == 9\n# notice that for inputs, we provide the return value of the ExecNode (return value of ExecNode tagged \"add_v1\")\n# but for the outputs, we indicate the the ExecNode whose return value must return.\n</code></pre>"},{"location":"#subdag-execution","title":"SubDAG Execution","text":"<p>You can execute a DAG inside another DAG. This can be useful if you want have a logical separation of your code. </p> <pre><code>@xn\ndef add(x, y):\nreturn x + y\n@dag\ndef sub_dag(x):\nreturn add(x, 1)  \n@dag\ndef main_dag(x):\nreturn sub_dag(x)\nassert main_dag(2) == 3\n</code></pre> <p>It also can be used with conditional execution to run a subgraph only if a condition is met.</p> <pre><code>@xn\ndef print_positive(x):\nassert x &gt; 0\nprint(f\"{x} is positive\")\n@xn\ndef print_negative(x):\nassert x &lt; 0\nprint(f\"{x} is negative\")\n@dag\ndef sub_dag_positive(x):\nprint_positive(x)\nreturn x\n@dag\ndef sub_dag_negative(x):\nprint_negative(x)\nreturn x\n@dag \ndef main_dag(x):\nv1 = sub_dag_positive(x, twz_active=x &gt; 0)\nv2 = sub_dag_negative(x, twz_active=x &lt; 0)\nreturn v1, v2\n# prints 1 is positive\n# doesn't print 1 is negative because not executed\nassert main_dag(1) == (1, None)\n# doesn't print -1 is positive because not executed\n# prints -1 is negative\nassert main_dag(-1) == (None, -1)\n</code></pre>"},{"location":"#resource-usage-for-execution","title":"Resource Usage for Execution","text":"<p>You can control the resource used to run a specific <code>ExecNode</code>. By default, all <code>ExecNode</code>s run in threads inside a ThreadPoolExecutor. This can be changed by setting the <code>resource</code> parameter of the <code>ExecNode</code>. The following resources are available:</p> <ol> <li>\"main-thread\": Run the <code>ExecNode</code> inside the main thread without Pickling the data to pass it to the threads etc.</li> <li>\"thread\": Run the <code>ExecNode</code> inside a thread (default).</li> <li>\"async-thread\": Run the <code>ExecNode</code> inside an asyncio thread.</li> </ol> <pre><code>from tawazi import Resource\nimport threading\n@xn(resource=Resource.main_thread)\ndef run_in_main_thread(main_thread_id):\nassert main_thread_id == threading.get_ident()\nprint(f\"I am running in the main thread with thread id {threading.get_ident()}\")\n@xn(resource=Resource.thread)\ndef run_in_thread(main_thread_id):\nassert main_thread_id != threading.get_ident()\nprint(f\"I am running in a thread with thread id {threading.get_ident()}\")\n@xn(resource=Resource.async_thread)\ndef run_in_async_thread(main_thread_id):\nassert main_thread_id != threading.get_ident()\nprint(f\"I am running in an async thread with thread id {threading.get_ident()}\")\n@dag\ndef dag_with_resource(main_thread_id):\nrun_in_main_thread(main_thread_id)\nrun_in_thread(main_thread_id)\nrun_in_async_thread(main_thread_id)\ndag_with_resource(threading.get_ident())\n</code></pre> <p>You can also set the default resource for all <code>ExecNode</code>s by setting the environment variable <code>TAWAZI_DEFAULT_RESOURCE</code> to either \"thread\" or \"main-thread\" or \"async-thread\".</p>"},{"location":"#asyncdag","title":"AsyncDAG","text":"<p>You can run make an <code>AsyncDAG</code> instead of a normal Sync DAG. This is useful if you want to run your <code>DAG</code> in an async context. The <code>AsyncDAG</code> behaves exactly like a normal <code>DAG</code> but has the advantage of giving the hand to the event loop if your code in the <code>ExecNode</code>s releases the GIL.</p> <p>NOTE: Your ExecNode should use the \"async-thread\" resource to give the hand to the event loop. Otherwise, the event loop will be blocked.</p> <pre><code># will be awaited in the AsyncDAG's scheduler.\n@xn(resource=Resource.async_thread)\ndef add_async(x, y):\nreturn x + y\n@dag(is_async=True)\ndef my_async_dag(x):\nreturn add(x, 1)\nimport asyncio\nimport numpy as np\n# using numpy in the example to show that the event loop is not blocked!\n#  because numpy releases the GIL.\nres = asyncio.run(my_async_dag(np.zeros(1000)))\nassert (res == np.ones(1000)).all()\n</code></pre>"},{"location":"#limitations","title":"Limitations","text":"<ol> <li>All code inside a dag descriptor function must be either an @xn decorated functions calls and arguments passed arguments. Otherwise the behavior of the DAG might be unpredictable</li> <li>Because the main function serves only for the purpose of describing the dependencies, the code that it executes should only describe dependencies. Hence when debugging your code, it will be impossible to view the data movement inside this function. However, you can debug code inside of a node.</li> <li>You can only execute a <code>DAG</code> in a sync context, i.e. it shouldn't be executed inside a running event loop because tawazi uses an internal event loop. If you want to run it in an async context, transform your <code>DAG</code> into an <code>AsyncDAG</code> and await it. </li> <li>You can only run a SyncDAG inside another DAG. You can't run an AsyncDAG inside a SyncDAG!</li> <li>MyPy typing is supported. However, for certain cases it is not currently possible to support typing: (<code>twz_tag</code>, <code>twz_active</code>, <code>twz_unpack_to</code> etc.). This is because of pep612's limitation for concatenating-keyword-parameters. As a workaround, you can currently add <code>**kwargs</code> to your original function declaring that it can accept keyworded arguments. However none of the inline tawazi specific parameters (<code>twz_*</code>) parameters will be passed to your function:</li> </ol> <pre><code>@xn\ndef f(x: int):\nreturn x\nf(2)  # works\ntry:\n# f() got an unexpected keyword argument 'twz_tag'\nf(2, twz_tag=\"twinkle\")  # fails (mypy error)\nexcept TypeError:\n...\n@xn\ndef f_with_kwargs(x: int, **kwargs):\nreturn x\nf_with_kwargs(2, twz_tag=\"toes\")  # works\n</code></pre>"},{"location":"DAGExecution/","title":"DAGExecution","text":""},{"location":"DAGExecution/#tawazi._dag.dag.BaseDAGExecution","title":"<code>BaseDAGExecution</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[P, RVDAG]</code></p> <p>A disposable callable instance of a DAG.</p> <p>It holds information about the last execution and is not threadsafe.</p> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>DAG</code> <p>The attached DAG.</p> required <code>target_nodes</code> <code>Optional[List[Alias]]</code> <p>The leave ExecNodes to execute. If None will execute all ExecNodes.</p> <code>None</code> <code>exclude_nodes</code> <code>Optional[List[Alias]]</code> <p>The leave ExecNodes to exclude. If None will exclude no ExecNode.</p> <code>None</code> <code>root_nodes</code> <code>Optional[List[Alias]]</code> <p>The base ExecNodes that will server as ancestor for the graph. If None will run all ExecNodes.</p> <code>None</code> <code>cache_deps_of</code> <code>Optional[List[Alias]]</code> <p>cache all the dependencies of these nodes. This option can not be used together with target_nodes nor exclude_nodes.</p> <code>None</code> <code>cache_in</code> <code>str</code> <p>the path to the file where the execution should be cached. The path should end in <code>.pkl</code>. Will skip caching if <code>cache_in</code> is Falsy.</p> <code>''</code> <code>from_cache</code> <code>str</code> <p>the path to the file where the execution should be loaded from. The path should end in <code>.pkl</code>. Will skip loading from cache if <code>from_cache</code> is Falsy.</p> <code>''</code>"},{"location":"DAGExecution/#tawazi._dag.dag.BaseDAGExecution.results","title":"<code>results: StrictDict[Identifier, Any]</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the results of the previous DAGExecution.</p> <p>Before the DAG is executed, the results are the same as the underlying DAG. This also includes before/after setup. After Execution, the results have been enriched with all the ExecNodes' results.</p>"},{"location":"DAGExecution/#tawazi._dag.DAGExecution","title":"<code>DAGExecution</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BaseDAGExecution[P, RVDAG]</code></p> <p>Sync implementation of BaseDAGExecution.</p>"},{"location":"DAGExecution/#tawazi._dag.DAGExecution.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Call the DAG.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>positional arguments to pass in to the DAG</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>keyword arguments to pass in to the DAG</p> <code>{}</code> <p>Raises:</p> Type Description <code>TawaziUsageError</code> <p>if the DAGExecution has already been executed.</p> <p>Returns:</p> Name Type Description <code>RVDAG</code> <code>RVDAG</code> <p>the return value of the DAG's Execution</p>"},{"location":"DAGExecution/#tawazi._dag.DAGExecution.setup","title":"<code>setup()</code>","text":"<p>Same thing as DAG.setup but <code>target_nodes</code> and <code>exclude_nodes</code> come from the DAGExecution's init.</p>"},{"location":"DAGExecution/#tawazi._dag.AsyncDAGExecution","title":"<code>AsyncDAGExecution</code>","text":"<p>             Bases: <code>BaseDAGExecution[P, RVDAG]</code></p> <p>Async implementation of BaseDAGExecution.</p>"},{"location":"DAGExecution/#tawazi._dag.AsyncDAGExecution.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Call the DAG.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>positional arguments to pass in to the DAG</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>keyword arguments to pass in to the DAG</p> <code>{}</code> <p>Raises:</p> Type Description <code>TawaziUsageError</code> <p>if the DAGExecution has already been executed.</p> <p>Returns:</p> Name Type Description <code>RVDAG</code> <code>RVDAG</code> <p>the return value of the DAG's Execution</p>"},{"location":"DAGExecution/#tawazi._dag.AsyncDAGExecution.setup","title":"<code>setup()</code>  <code>async</code>","text":"<p>Same thing as DAG.setup but <code>target_nodes</code> and <code>exclude_nodes</code> come from the DAGExecution's init.</p>"},{"location":"dag/","title":"DAG","text":""},{"location":"dag/#tawazi._dag.dag.BaseDAG","title":"<code>BaseDAG</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[P, RVDAG]</code></p> <p>Data Structure containing ExecNodes with interdependencies.</p> <p>Please do not instantiate this class directly. Use the decorator <code>@dag</code> instead. The ExecNodes can be executed in parallel with the following restrictions:     * Limited number of threads.     * Parallelization constraint of each ExecNode (is_sequential attribute)     * Priority of each ExecNode (priority attribute)     * Specific Resource per ExecNode (resource attribute) This Class has two flavors:     * DAG: for synchronous execution     * AsyncDAG: for asynchronous execution</p> <p>Parameters:</p> Name Type Description Default <code>exec_nodes</code> <code>StrictDict[Identifier, ExecNode]</code> <p>all the ExecNodes</p> required <code>input_uxns</code> <code>List[UsageExecNode]</code> <p>all the input UsageExecNodes</p> required <code>return_uxns</code> <code>ReturnUXNsType</code> <p>the return UsageExecNodes of various types: None, a single value, tuple, list, dict.</p> required <code>max_concurrency</code> <code>int</code> <p>the maximal number of threads running in parallel</p> <code>1</code>"},{"location":"dag/#tawazi._dag.dag.BaseDAG.config_from_dict","title":"<code>config_from_dict(config)</code>","text":"<p>Allows reconfiguring the parameters of the nodes from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict[str, Any]</code> <p>the dictionary containing the config example: {\"nodes\": {\"a\": {\"priority\": 3, \"is_sequential\": True}}, \"max_concurrency\": 3}</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if two nodes are configured by the provided config (which is ambiguous)</p>"},{"location":"dag/#tawazi._dag.dag.BaseDAG.config_from_json","title":"<code>config_from_json(config_path)</code>","text":"<p>Allows reconfiguring the parameters of the nodes from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>the path to the JSON file</p> required"},{"location":"dag/#tawazi._dag.dag.BaseDAG.config_from_yaml","title":"<code>config_from_yaml(config_path)</code>","text":"<p>Allows reconfiguring the parameters of the nodes from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>the path to the YAML file</p> required"},{"location":"dag/#tawazi._dag.dag.BaseDAG.get_node_by_id","title":"<code>get_node_by_id(node_id)</code>","text":"<p>Get the ExecNode with the given id.</p> the returned ExecNode is not modified by any execution! <p>This means that you can not get the result of its execution via <code>DAG.get_node_by_id(&lt;id&gt;).result</code>. In order to do that, you need to make a DAGExecution and then call  <code>DAGExecution.get_node_by_id(&lt;id&gt;).result</code>, which will contain the results.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>Identifier</code> <p>id of the ExecNode</p> required <p>Returns:</p> Name Type Description <code>ExecNode</code> <code>ExecNode</code> <p>corresponding ExecNode</p>"},{"location":"dag/#tawazi._dag.dag.BaseDAG.get_nodes_by_tag","title":"<code>get_nodes_by_tag(tag)</code>","text":"<p>Get the ExecNodes with the given tag.</p> the returned ExecNode is not modified by any execution! <p>This means that you can not get the result of its execution via <code>DAG.get_nodes_by_tag(&lt;tag&gt;).result</code>. In order to do that, you need to make a DAGExecution and then call  <code>DAGExecution.get_nodes_by_tag(&lt;tag&gt;).result</code>, which will contain the results.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Any</code> <p>tag of the ExecNodes</p> required <p>Returns:</p> Type Description <code>List[ExecNode]</code> <p>List[ExecNode]: corresponding ExecNodes</p>"},{"location":"dag/#tawazi._dag.dag.BaseDAG.compose","title":"<code>compose(qualname, inputs, outputs, is_async=None, **kwargs)</code>","text":"<p>Compose a new DAG using inputs and outputs ExecNodes (Experimental).</p> <p>All provided <code>Alias</code>es must point to unique <code>ExecNode</code>s. Otherwise ValueError is raised The user is responsible to correctly specify inputs and outputs signature of the <code>DAG</code>. * The inputs can be specified as a single <code>Alias</code> or a <code>Sequence</code> of <code>Alias</code>es. * The outputs can be specified as a single <code>Alias</code> (a single value is returned) or a <code>Sequence</code> of <code>Alias</code>es in which case a Tuple of the values are returned. If outputs are specified as [], () is returned. The syntax is the following:</p> <pre><code>&gt;&gt;&gt; from tawazi import dag, xn, DAG\n&gt;&gt;&gt; from typing import Tuple, Any\n&gt;&gt;&gt; @xn\n... def unwanted_xn() -&gt; int: return 42\n&gt;&gt;&gt; @xn\n... def x(v: Any) -&gt; int: return int(v)\n&gt;&gt;&gt; @xn\n... def y(v: Any) -&gt; str: return str(v)\n&gt;&gt;&gt; @xn\n... def z(x: int, y: str) -&gt; float: return float(x) + float(y)\n&gt;&gt;&gt; @dag\n... def pipe() -&gt; Tuple[int, float, int]:\n...     a = unwanted_xn()\n...     res = z(x(1), y(1))\n...     b = unwanted_xn()\n...     return a, res, b\n&gt;&gt;&gt; composed_dag = pipe.compose(\"twinkle\", [x, y], z)\n&gt;&gt;&gt; assert composed_dag(1, 1) == 2.0\n&gt;&gt;&gt; # composed_dag: DAG[[int, str], float] = pipe.compose([x, y], [z])  # optional typing of the returned DAG!\n&gt;&gt;&gt; # assert composed_dag(1, 1) == 2.0  # type checked!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>qualname</code> <code>str</code> <p>the name of the composed DAG</p> required <code>inputs</code> <code>(ellipsis, Alias | List[Alias])</code> <p>the Inputs nodes whose results are provided. Provide ... to specify that you will provide every argument of the original DAG.</p> required <code>outputs</code> <code>Alias | List[Alias]</code> <p>the Output nodes that must execute last, The ones that will generate results</p> required <code>is_async</code> <code>bool | None</code> <p>if True, the composed DAG will be an AsyncDAG, if False, it will be a DAG. Defaults to whatever the original DAG is.</p> <code>None</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>additional arguments to be passed to the DAG's constructor</p> <code>{}</code>"},{"location":"dag/#tawazi._dag.DAG","title":"<code>DAG</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BaseDAG[P, RVDAG]</code></p> <p>SyncDAG implementation of the BaseDAG.</p>"},{"location":"dag/#tawazi._dag.DAG.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Execute the DAG scheduler via a similar interface to the function that describes the dependencies.</p> <p>Note: Currently kwargs are not supported.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>arguments to be passed to the call of the DAG</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>keyword arguments to be passed to the call of the DAG</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RVDAG</code> <code>RVDAG</code> <p>return value of the DAG's execution</p> <p>Raises:</p> Type Description <code>TawaziUsageError</code> <p>kwargs are passed</p>"},{"location":"dag/#tawazi._dag.DAG.executor","title":"<code>executor(target_nodes=None, exclude_nodes=None, root_nodes=None, cache_deps_of=None, cache_in='', from_cache='')</code>","text":"<p>Generates a DAGExecution for the DAG.</p> <p>Parameters:</p> Name Type Description Default <code>target_nodes</code> <code>Optional[Sequence[Alias]]</code> <p>the nodes to execute, excluding all nodes that can be excluded</p> <code>None</code> <code>exclude_nodes</code> <code>Optional[Sequence[Alias]]</code> <p>the nodes to exclude from the execution</p> <code>None</code> <code>root_nodes</code> <code>Optional[Sequence[Alias]]</code> <p>these nodes and their children will be included in the execution</p> <code>None</code> <code>cache_deps_of</code> <code>Optional[Sequence[Alias]]</code> <p>which nodes to cache the dependencies of</p> <code>None</code> <code>cache_in</code> <code>str</code> <p>the path to the file where to cache</p> <code>''</code> <code>from_cache</code> <code>str</code> <p>the cache</p> <code>''</code> <p>Returns:</p> Type Description <code>DAGExecution[P, RVDAG]</code> <p>the DAGExecution object associated with the dag</p>"},{"location":"dag/#tawazi._dag.DAG.setup","title":"<code>setup(target_nodes=None, exclude_nodes=None, root_nodes=None)</code>","text":"<p>Run the setup ExecNodes for the DAG.</p> <p>If target_nodes are provided, run only the necessary setup ExecNodes, otherwise will run all setup ExecNodes. NOTE: <code>DAG</code> arguments should not be passed to setup ExecNodes.     Only pass in constants or setup <code>ExecNode</code>s results.</p> <p>Parameters:</p> Name Type Description Default <code>target_nodes</code> <code>Optional[List[XNId]]</code> <p>The ExecNodes that the user aims to use in the DAG. This might include setup or non setup ExecNodes. If None is provided, will run all setup ExecNodes. Defaults to None.</p> <code>None</code> <code>exclude_nodes</code> <code>Optional[List[XNId]]</code> <p>The ExecNodes that the user aims to exclude from the DAG. The user is responsible for ensuring that the overlapping between the target_nodes and exclude_nodes is logical.</p> <code>None</code> <code>root_nodes</code> <code>Optional[List[XNId]]</code> <p>The ExecNodes that the user aims to select as ancestor nodes. The user is responsible for ensuring that the overlapping between the target_nodes, the exclude_nodes and the root nodes is logical.</p> <code>None</code>"},{"location":"dag/#tawazi._dag.AsyncDAG","title":"<code>AsyncDAG</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BaseDAG[P, RVDAG]</code></p>"},{"location":"dag/#tawazi._dag.AsyncDAG.__call__","title":"<code>__call__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Execute the DAG scheduler via a similar interface to the function that describes the dependencies.</p> <p>Note: Currently kwargs are not supported.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>arguments to be passed to the call of the DAG</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>keyword arguments to be passed to the call of the DAG</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RVDAG</code> <code>RVDAG</code> <p>return value of the DAG's execution</p> <p>Raises:</p> Type Description <code>TawaziUsageError</code> <p>kwargs are passed</p>"},{"location":"dag/#tawazi._dag.AsyncDAG.executor","title":"<code>executor(target_nodes=None, exclude_nodes=None, root_nodes=None, cache_deps_of=None, cache_in='', from_cache='')</code>","text":"<p>Generates a AsyncDAGExecution for the current AsyncDAG.</p> <p>Parameters:</p> Name Type Description Default <code>target_nodes</code> <code>Optional[Sequence[Alias]]</code> <p>the nodes to execute, excluding all nodes that can be excluded</p> <code>None</code> <code>exclude_nodes</code> <code>Optional[Sequence[Alias]]</code> <p>the nodes to exclude from the execution</p> <code>None</code> <code>root_nodes</code> <code>Optional[Sequence[Alias]]</code> <p>these nodes and their children will be included in the execution</p> <code>None</code> <code>cache_deps_of</code> <code>Optional[Sequence[Alias]]</code> <p>which nodes to cache the dependencies of</p> <code>None</code> <code>cache_in</code> <code>str</code> <p>the path to the file where to cache</p> <code>''</code> <code>from_cache</code> <code>str</code> <p>the cache</p> <code>''</code> <p>Returns:</p> Type Description <code>AsyncDAGExecution[P, RVDAG]</code> <p>the DAGExecution object associated with the dag</p>"},{"location":"dag/#tawazi._dag.AsyncDAG.setup","title":"<code>setup(target_nodes=None, exclude_nodes=None, root_nodes=None)</code>  <code>async</code>","text":"<p>Run the setup ExecNodes for the DAG.</p> <p>If target_nodes are provided, run only the necessary setup ExecNodes, otherwise will run all setup ExecNodes. NOTE: <code>DAG</code> arguments should not be passed to setup ExecNodes.     Only pass in constants or setup <code>ExecNode</code>s results.</p> <p>Parameters:</p> Name Type Description Default <code>target_nodes</code> <code>Optional[List[XNId]]</code> <p>The ExecNodes that the user aims to use in the DAG. This might include setup or non setup ExecNodes. If None is provided, will run all setup ExecNodes. Defaults to None.</p> <code>None</code> <code>exclude_nodes</code> <code>Optional[List[XNId]]</code> <p>The ExecNodes that the user aims to exclude from the DAG. The user is responsible for ensuring that the overlapping between the target_nodes and exclude_nodes is logical.</p> <code>None</code> <code>root_nodes</code> <code>Optional[List[XNId]]</code> <p>The ExecNodes that the user aims to select as ancestor nodes. The user is responsible for ensuring that the overlapping between the target_nodes, the exclude_nodes and the root nodes is logical.</p> <code>None</code>"},{"location":"decorators/","title":"decorators","text":""},{"location":"decorators/#tawazi._decorators","title":"<code>_decorators</code>","text":"<p>Decorators of Tawazi.</p> <p>The user should use the decorators <code>@dag</code> and <code>@xn</code> to create Tawazi objects <code>DAG</code> and <code>ExecNode</code>.</p>"},{"location":"decorators/#tawazi._decorators.xn","title":"<code>xn(func=None, *, priority=0, is_sequential=cfg.TAWAZI_IS_SEQUENTIAL, debug=False, tag=None, setup=False, unpack_to=None, resource=cfg.TAWAZI_DEFAULT_RESOURCE)</code>","text":"<p>Decorate a normal function to make it an ExecNode.</p> <p>When the decorated function is called inside a <code>DAG</code>, you are actually calling an <code>ExecNode</code>. This way we can record the dependencies in order to build the actual DAG. Please check the example in the README for a guide to the usage.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>[Callable[P, RVXN]</code> <p>a Callable that will be executed in the <code>DAG</code></p> <code>None</code> <code>priority</code> <code>int</code> <p>priority of the execution with respect to other <code>ExecNode</code>s</p> <code>0</code> <code>is_sequential</code> <code>bool</code> <p>whether to allow the execution of this <code>ExecNode</code> with others or not. If <code>True</code>, all other <code>ExecNode</code> currently running will stop before this one starts executing.</p> <code>TAWAZI_IS_SEQUENTIAL</code> <code>debug</code> <code>bool</code> <p>if <code>True</code>, will execute only when Debug mode is active. a debug <code>ExecNode</code> will run its inputs exists regardless of subgraph choice.</p> <code>False</code> <code>tag</code> <code>Optional[TagOrTags]</code> <p>a str or Tuple[str] to tag this ExecNode. If Tuple[str] is given, every value of the tuple is used as tag. Notice that multiple ExecNodes can have the same tag.</p> <code>None</code> <code>setup</code> <code>bool</code> <p>if True, will be executed only once during the lifetime of a <code>DAG</code> instance. Setup <code>ExecNode</code>s are meant to be used to load heavy data only once inside the execution pipeline and then be used as if the results of their execution were cached. This can be useful if you want to load heavy ML models, heavy Data etc. Note that you can run all / subset of the setup nodes by invoking the DAG.setup method NOTE setup nodes are currently not threadsafe!     because they are shared between all threads!     If you execute the same pipeline in multiple threads during the setup phase, the behavior is undefined.     It is best to invoke the DAG.setup method before using the DAG in a multithreaded environment.     This problem will be resolved in the future</p> <code>False</code> <code>unpack_to</code> <code>Optional[int]</code> <p>if not None, this ExecNode's execution must return unpacked results corresponding                        to the given value</p> <code>None</code> <code>resource</code> <code>str</code> <p>the resource to use to execute this ExecNode. Defaults to \"thread\".</p> <code>TAWAZI_DEFAULT_RESOURCE</code> <p>Returns:</p> Name Type Description <code>LazyExecNode</code> <code>Union[Callable[[Callable[P, RVXN]], LazyExecNode[P, RVXN]], LazyExecNode[P, RVXN]]</code> <p>The decorated function wrapped in an <code>ExecNode</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the decorated function passed is not a <code>Callable</code>.</p>"},{"location":"decorators/#tawazi._decorators.dag","title":"<code>dag(declare_dag_function=None, *, max_concurrency=1, is_async=False)</code>","text":"<p>Transform the declared <code>ExecNode</code>s into a DAG that can be executed by Tawazi's scheduler.</p> <p>The same DAG can be executed multiple times. Note: dag is thread safe because it uses an internal lock.     If you need to construct lots of DAGs in multiple threads,     it is best to construct your dag once and then use it as much as you like. Please check the example in the README for a guide to the usage.</p> <p>Parameters:</p> Name Type Description Default <code>declare_dag_function</code> <code>Optional[Callable[P, RVDAG]]</code> <p>a function that describes the execution of the DAG. This function should only contain calls to <code>ExecNode</code>s and data Exchange between them. (i.e. You can not use a normal Python function inside it unless decorated with <code>@xn</code>.) However, you can use some simple python code to generate constants. These constants are computed only once during the <code>DAG</code> declaration.</p> <code>None</code> <code>max_concurrency</code> <code>int</code> <p>the maximum number of concurrent threads to execute in parallel.</p> <code>1</code> <code>is_async</code> <code>bool</code> <p>if True, the returned object will be an <code>AsyncDAG</code> instead of a <code>DAG</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[DAG[P, RVDAG], AsyncDAG[P, RVDAG], Callable[[Callable[P, RVDAG]], Union[DAG[P, RVDAG], AsyncDAG[P, RVDAG]]]]</code> <p>a <code>DAG</code> instance that can be used just like a normal Python function. It will be executed by Tawazi's scheduler.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the decorated object is not a Callable.</p>"},{"location":"future_developments/","title":"Future Developments","text":""},{"location":"future_developments/#soon-to-be-released","title":"Soon to be released","text":"<p>A couple of features will be released soon:</p> <ul> <li>handle problems when calling <code>ExecNodes</code> wrongly.</li> <li>(for example when using args as parameters but only *kwargs are provided).</li> <li>Calling <code>ExecNodes</code> must be similar to calling the original function (must imitate the same signature otherwise raise the correct exception).</li> <li>improve the graph dependency rendering on the console (using graphviz).</li> <li>automatically generate release on new tag https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes#configuring-automatically-generated-release-notes</li> <li>use opnssf service to evaluate code best practices https://bestpractices.coreinfrastructure.org/fr/projects/1486</li> </ul>"},{"location":"future_developments/#features-to-be-discussed","title":"Features to be discussed","text":"<ul> <li>support multiprocessing.</li> <li>simulation of the execution using a <code>DAG</code> stored ledger.</li> <li>Disallow execution in parallel of some threads in parallel with some other threads.</li> <li>maybe by making a group of threads that are CPU bound and a group of threads that are IO bound ?</li> <li>save the results of the calculation in pickled format in case an error is encountered ? or just at the end of the run</li> <li>re-run the same calculations of the graph but take the input from the presaved pickle files instead</li> <li>put documentation about different cases where it is advantageous to use it</li> <li>in methods not only in functions</li> <li>in a gunicorn application</li> </ul>"},{"location":"nodes/","title":"ExecNodes","text":"<p>warning: This page describes some internal functionalities of Tawazi, it is still subject to change during minor releases.</p>"},{"location":"nodes/#tawazi.node.ExecNode","title":"<code>ExecNode</code>  <code>dataclass</code>","text":"<p>Base class for executable node in a DAG.</p> <p>An ExecNode is an Object that can be executed inside a DAG scheduler. It basically consists of a function (exec_function) that takes args and kwargs and returns a value. When the ExecNode is executed in the DAG, the resulting value will be stored in a dictionary. Note: This class is not meant to be instantiated directly.     Please use <code>@xn</code> decorator.</p> <p>Parameters:</p> Name Type Description Default <code>id_</code> <code>Identifier</code> <p>Identifier.</p> <code>field(default='')</code> <code>exec_function</code> <code>Callable</code> <p>callable to execute in the DAG.</p> <code>field(default_factory=lambda : lambda : None)</code> <code>args</code> <code>Optional[List[ExecNode]]</code> <p>*args to pass to exec_function during execution.</p> <code>field(default_factory=list)</code> <code>kwargs</code> <code>Optional[Dict[str, ExecNode]]</code> <p>**kwargs to pass to exec_function during execution.</p> <code>field(default_factory=dict)</code> <code>priority</code> <code>int</code> <p>priority compared to other ExecNodes; the higher the number the higher the priority.</p> <code>0</code> <code>is_sequential</code> <code>bool</code> <p>whether to execute this ExecNode in sequential order with respect to others. (i.e. When this ExecNode must be executed, all other nodes are waited to finish before starting execution.) Defaults to False.</p> <code>TAWAZI_IS_SEQUENTIAL</code> <code>debug</code> <code>bool</code> <p>Make this ExecNode a debug Node. Defaults to False.</p> <code>False</code> <code>tag</code> <code>TagOrTags</code> <p>Attach a Tag or Tags to this ExecNode. Defaults to None.</p> <code>None</code> <code>setup</code> <code>bool</code> <p>Make this ExecNode a setup Node. Defaults to False.</p> <code>False</code> <code>unpack_to</code> <code>Optional[int]</code> <p>if not None, this ExecNode's execution must return unpacked results corresponding to the given value</p> <code>None</code> <code>resource</code> <code>str</code> <p>The resource to use to execute this ExecNode. Defaults to \"thread\".</p> <code>TAWAZI_DEFAULT_RESOURCE</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if setup and debug are both True.</p>"},{"location":"nodes/#tawazi.node.ExecNode.id","title":"<code>id: Identifier</code>  <code>property</code>","text":"<p>The identifier of this ExecNode.</p>"},{"location":"nodes/#tawazi.node.ExecNode.tag","title":"<code>tag: Optional[TagOrTags] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nodes/#tawazi.node.ExecNode.debug","title":"<code>debug: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nodes/#tawazi.node.ExecNode.setup","title":"<code>setup: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nodes/#tawazi.node.ExecNode.priority","title":"<code>priority: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nodes/#tawazi.node.ExecNode.is_sequential","title":"<code>is_sequential: bool = cfg.TAWAZI_IS_SEQUENTIAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"nodes/#tawazi.node.ExecNode.executed","title":"<code>executed(results)</code>","text":"<p>Returns whether this ExecNode was executed or not.</p>"},{"location":"others/","title":"Others","text":""},{"location":"others/#tawazi.cfg","title":"<code>cfg = Config()</code>  <code>module-attribute</code>","text":""},{"location":"others/#tawazi.and_","title":"<code>and_(a, b)</code>","text":"<p>Equivalent of <code>and</code> wrapped in ExecNode.</p>"},{"location":"others/#tawazi.or_","title":"<code>or_(a, b)</code>","text":"<p>Equivalent of <code>or</code> wrapped in ExecNode.</p>"},{"location":"others/#tawazi.not_","title":"<code>not_(a)</code>","text":"<p>Equivalent of <code>not</code> wrapped in ExecNode.</p>"},{"location":"others/#tawazi.Resource","title":"<code>Resource</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>The Resource to use launching ExecNodes inside the DAG scheduler a DAG.</p> <pre><code>Resource can be either:\n1. \"main-thread\": Launch the ExecNode inside the main thread, directly inside the main scheduler.\n2. \"thread\": Launch the ExecNode in a thread (Default)\n3. \"async-thread\": Launch the ExecNode in an async thread and await it\n\nNotice that when \"main-thread\" is used, some of the scheduler functionalities stop working as previously expected:\n1. No new ExecNode will be launched during the execution of the corresponding ExecNode\n2. If timeout is set on the corresponding ExecNode, it is not guaranteed to work properly.\n</code></pre>"},{"location":"others/#tawazi.Resource.main_thread","title":"<code>main_thread: str = 'main-thread'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"others/#tawazi.Resource.thread","title":"<code>thread: str = 'thread'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"others/#tawazi.Resource.async_thread","title":"<code>async_thread: str = 'async-thread'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""}]}